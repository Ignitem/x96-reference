import{_ as t,c as d,f as c,o}from"./app-Lq2sJREA.js";const r={};function i(a,e){return o(),d("div",null,e[0]||(e[0]=[c(`<h1 id="registers" tabindex="-1"><a class="header-anchor" href="#registers"><span>Registers</span></a></h1><h2 id="main-registers" tabindex="-1"><a class="header-anchor" href="#main-registers"><span>Main Registers</span></a></h2><p>In x96, the register naming scheme and internal addressing is very different from x86, here are the main registers:</p><table><thead><tr><th>Name</th><th>Size</th><th style="text-align:right;">Internal Address (binary)</th></tr></thead><tbody><tr><td><code>ras</code></td><td>sedecimbyte (<code>s</code>, 128-bit)</td><td style="text-align:right;"><code>0b(00 1111111111111111)</code></td></tr><tr><td><code>rbs</code></td><td>sedecimbyte (<code>s</code>, 128-bit)</td><td style="text-align:right;"><code>0b(01 1111111111111111)</code></td></tr><tr><td><code>rcs</code></td><td>sedecimbyte (<code>s</code>, 128-bit)</td><td style="text-align:right;"><code>0b(10 1111111111111111)</code></td></tr><tr><td><code>rds</code></td><td>sedecimbyte (<code>s</code>, 128-bit)</td><td style="text-align:right;"><code>0b(11 1111111111111111)</code></td></tr><tr><td><code>rao</code></td><td>octo (<code>o</code>, 64-bit)</td><td style="text-align:right;"><code>0b(00 0000000011111111)</code></td></tr><tr><td><code>rbo</code></td><td>octo (<code>o</code>, 64-bit)</td><td style="text-align:right;"><code>0b(01 0000000011111111)</code></td></tr><tr><td><code>rco</code></td><td>octo (<code>o</code>, 64-bit)</td><td style="text-align:right;"><code>0b(10 0000000011111111)</code></td></tr><tr><td><code>rdo</code></td><td>octo (<code>o</code>, 64-bit)</td><td style="text-align:right;"><code>0b(11 0000000011111111)</code></td></tr><tr><td><code>rad</code></td><td>dword (<code>d</code>, 32-bit)</td><td style="text-align:right;"><code>0b(00 0000000000001111)</code></td></tr><tr><td><code>rbd</code></td><td>dword (<code>d</code>, 32-bit)</td><td style="text-align:right;"><code>0b(01 0000000000001111)</code></td></tr><tr><td><code>rcd</code></td><td>dword (<code>d</code>, 32-bit)</td><td style="text-align:right;"><code>0b(10 0000000000001111)</code></td></tr><tr><td><code>rdd</code></td><td>dword (<code>d</code>, 32-bit)</td><td style="text-align:right;"><code>0b(11 0000000000001111)</code></td></tr><tr><td><code>raw</code></td><td>word (<code>w</code>, 16-bit)</td><td style="text-align:right;"><code>0b(00 0000000000000011)</code></td></tr><tr><td><code>rbw</code></td><td>word (<code>w</code>, 16-bit)</td><td style="text-align:right;"><code>0b(01 0000000000000011)</code></td></tr><tr><td><code>rcw</code></td><td>word (<code>w</code>, 16-bit)</td><td style="text-align:right;"><code>0b(10 0000000000000011)</code></td></tr><tr><td><code>rdw</code></td><td>word (<code>w</code>, 16-bit)</td><td style="text-align:right;"><code>0b(11 0000000000000011)</code></td></tr><tr><td><code>rab</code></td><td>byte (<code>b</code>, 8-bit)</td><td style="text-align:right;"><code>0b(00 0000000000000001)</code></td></tr><tr><td><code>rbb</code></td><td>byte (<code>b</code>, 8-bit)</td><td style="text-align:right;"><code>0b(01 0000000000000001)</code></td></tr><tr><td><code>rcb</code></td><td>byte (<code>b</code>, 8-bit)</td><td style="text-align:right;"><code>0b(10 0000000000000001)</code></td></tr><tr><td><code>rdb</code></td><td>byte (<code>b</code>, 8-bit)</td><td style="text-align:right;"><code>0b(11 0000000000000001)</code></td></tr></tbody></table><h2 id="naming-scheme-internal-addressing" tabindex="-1"><a class="header-anchor" href="#naming-scheme-internal-addressing"><span>Naming Scheme &amp; Internal Addressing</span></a></h2><p>x96 standardize the naming scheme and make it scalable, with a simple formula to find it, while still being descriptive despite being concise.</p><p>The naming scheme follow this rule:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">regPart_prefix + regId + mainReg_sizeSuffix</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>Where <code>regPart_prefix</code> is based on the location of the register in the main register, <code>regId</code> is the letter identifying the register (<code>a</code>, <code>b</code>, <code>c</code> and <code>d</code>) and <code>mainReg_sizeSuffix</code> is the suffix identifying the size of the main register.</p><p><code>regPart_prefix</code> follow these rules:</p><ul><li>If it&#39;s a main register (top-most register or lower bits of a top-most register) then it&#39;s <code>&quot;r&quot;</code></li><li>If it&#39;s the higher bits of its parent register, then it&#39;s first character is <code>&#39;h&#39;</code></li><li>If it&#39;s the lower bits of its parent register, then it&#39;s first character is <code>&#39;l&#39;</code></li><li>Then it follow a hierarchical structure by adding the <code>regPart_prefix</code> of it&#39;s parent register (for the higher part of main registers, the <code>&#39;r&#39;</code> is replaced by the <code>&#39;h&#39;</code>)</li></ul><p>These parts of main registers are called &quot;hierarchical registers&quot;.</p><p>This new naming convention reflect in the internal addresses, where the first 2 bits are <code>regId - &#39;a&#39;</code> and the next 16 bits are the 8-bit chunks of the top-most register affected by the hierarchical register.</p><p>Here&#39;s the schema of a x96 top-most register (<code>ras</code>) with its hierarchical registers, each row a deeper level:</p><table id="hierarchical-registers-schema"><tbody><tr><th class="sr-only">Top-most level - main register (128-bits)</th><td colspan="16" align="center"><code>ras</code></td></tr><tr><th class="sr-only">Second level - 64-bits</th><td colspan="8" align="center"><code>has</code></td><td colspan="8" align="center"><code>rao</code></td></tr><tr><th class="sr-only">Third level - 32-bits</th><td colspan="4" align="center"><code>hhas</code></td><td colspan="4" align="center"><code>lhas</code></td><td colspan="4" align="center"><code>hao</code></td><td colspan="4" align="center"><code>rad</code></td></tr><tr><th class="sr-only">Fourth level - 16-bits</th><td colspan="2" align="center"><code>hhhas</code></td><td colspan="2" align="center"><code>lhhas</code></td><td colspan="2" align="center"><code>hlhas</code></td><td colspan="2" align="center"><code>llhas</code></td><td colspan="2" align="center"><code>hhao</code></td><td colspan="2" align="center"><code>lhao</code></td><td colspan="2" align="center"><code>had</code></td><td colspan="2" align="center"><code>raw</code></td></tr><tr><th class="sr-only">Fifth (last) level - 8-bits</th><td align="center"><code>hhhhas</code></td><td align="center"><code>lhhhas</code></td><td align="center"><code>hlhhas</code></td><td align="center"><code>llhhas</code></td><td align="center"><code>hhlhas</code></td><td align="center"><code>lhlhas</code></td><td align="center"><code>hllhas</code></td><td align="center"><code>lllhas</code></td><td align="center"><code>hhhao</code></td><td align="center"><code>lhhao</code></td><td align="center"><code>hlhao</code></td><td align="center"><code>llhao</code></td><td align="center"><code>hhad</code></td><td align="center"><code>lhad</code></td><td align="center"><code>haw</code></td><td align="center"><code>rab</code></td></tr></tbody></table>`,15)]))}const n=t(r,[["render",i],["__file","registers.html.vue"]]),l=JSON.parse('{"path":"/registers.html","title":"Registers","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Main Registers","slug":"main-registers","link":"#main-registers","children":[]},{"level":2,"title":"Naming Scheme & Internal Addressing","slug":"naming-scheme-internal-addressing","link":"#naming-scheme-internal-addressing","children":[]}],"git":{"updatedTime":1728319271000,"contributors":[{"name":"foxy pirate cove / Fnaf","email":"108185011+foxypiratecove37350@users.noreply.github.com","commits":1}]},"filePathRelative":"registers.md"}');export{n as comp,l as data};
